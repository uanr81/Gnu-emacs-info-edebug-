17 Debugging Lisp Programs
**************************

Есть несколько способов, чтобы найти и исследовать проблемы в
программе Emacs Lisp.

   • Если проблема возникает при запуске программы, вы можете использовать
   встроенный в Emacs Lisp отладчик приостановить лисповское оценщик, и
   изучить и / или изменять свое внутреннее состояние.

   • Mожете использовать Edebug, отладчик на уровне исходного кода для Emacs Lisp.

   • Если синтаксический ошибка блокирует запуск Лиспа даже от чтения
   программы, вы можете найти причину ошибки с помощью лисповские команды
   редактирования.

   • Вы можете посмотреть на сообщения об ошибках и предупреждений,
   полученных байтов компилятора при компиляции программы.
   *Note Compiler Errors::.

   • Вы можете использовать пакет Testcover для проведения тестирования
покрытия по программе.

   • Вы можете использовать пакет ERT, чтобы написать регрессионные тесты
   для программы.  *Note the ERT manual: (ert)Top.

   • Вы можете профилировать программу, чтобы получить подсказки о том, как
   сделать его более эффективным.

   Другие полезные инструменты для отладки входных и выходных проблем
   файла искать (*note Terminal Input::) и ‘open-termscript’ функции
   (*note Terminal Output::).

* Menu:

* Debugger::            Отладчик оценщиком  для Emacs Lisp.
* Edebug::              Источник уровня Emacs Lisp отладчик.
* Syntax Errors::       Как найти синтаксические ошибки.
* Test Coverage::       Гарантируя, что вы проверили все ветви в вашем коде.
* Profiling::           Измерение ресурсов, которые использует ваш код.


File: elisp.info,  Node: Debugger,  Next: Edebug,  Up: Debugging

17.1 The Lisp Debugger
======================

Обычный "Lisp отладчик" предоставляет возможность приостановить оценку
формы. В то время как оценка приостанавливается (состояние, которое
обычно известный как "break"), вы можете просматривать стек во время
выполнения, проверять значения локальных или глобальных переменных,
или изменить эти значения. Так как разрыв является рекурсивным
редактирование, все обычные редактирования средства Emacs доступны; Вы
даже можете запускать программы, которые войдут в отладчик рекурсивно.
*Note Recursive Editing::.

* Menu:

* Error Debugging::       Ввод отладчика при возникновении ошибки.
* Infinite Loops::        Остановка и отладки программы, которая не завершается.
* Function Debugging::    Вызов отладчика, когда определенная функция вызывается.
* Explicit Debug::        Ввод его в определенный момент в программе.
* Using Debugger::        Что отладчик делает; что вы видите в то время как в нем.
* Debugger Commands::     Команды, используемые в отладчике.
* Invoking the Debugger:: Как вызвать функцию ‘debug’.
* Internals of Debugger:: Подпрограммы отладчика, а также глобальные переменные.


File: elisp.info,  Node: Error Debugging,  Next: Infinite Loops,  Up: Debugger

17.1.1 Entering the Debugger on an Error
----------------------------------------

вызов отладчика при возникновении ошибки
Самое важное время, чтобы войти в отладчик, когда происходит
лисповская ошибка. Это позволяет исследовать непосредственные причины
ошибки.

   Тем не менее, вход в отладчик не является нормальным следствием ошибки.
   Многие команды сигнала лисповской ошибки при вызове ненадо, и во время
   обычного редактирования было бы очень неудобно, чтобы войти в отладчик каждый
   раз, когда это происходит. Так что если вы хотите при ошибке войти в отладчик,
   установите переменную ‘debug-on-error’ в не-‘nil’. (команда
   ‘toggle-debug-on-error’ обеспечивает простой способ сделать это.)

 -- User Option: debug-on-error
     Эта переменная определяет, вызывается ли отладчик, когда сигнал об ошибке
     не обрабатывается. Если ‘debug-on-error’ установлено ‘t’ , все виды ошибок
     вызовут отладчик, за исключением тех, которые перечислены в
     ‘debug-ignored-errors’ (смотрите ниже). Если 'nil',вызван отладчик не будет.

     Значение также может быть список условий ошибок (*note Signaling Errors::).
     Затем отладчик вызывается только для условий ошибки в этом списке (за
     исключением тех, также перечислены в ‘debug-ignored-errors’). Например, если
     вы установите ‘debug-on-error’в список ‘(void-variable)’, отладчик вызывется
     только на наличие ошибок о переменной, которая не имеет никакого значения.

     Обратите внимание, что ‘eval-expression-debug-on-error’ отменяет эту
     переменную в некоторых случаях; Смотри ниже.

     Если эта переменная не-'nil ', Emacs не создает обработчик ошибок вокруг
     функций и часовыми процесс фильтрации. Таким образом, ошибки в этих функциях
     также не вызвают отладчик.  *Note Processes::.

 -- User Option: debug-ignored-errors
     Эта переменная определяет ошибки, которые не должны вызывать отладчик,
     независимо от значения ‘debug-on-error’. Её значение представляет собой
     список символов и/или регулярных выражений условий ошибки. Если ошибка
     соответствует каким-либо из этих условий символов, или если сообщение об
     ошибке соответствует любому из регулярных выражений, то эта ошибка не вызовет
     отладчик.

     Нормальное значение этой переменной включает в себя ‘user-error’, а также
     несколько ошибок, которые случаются часто во время редактирования, но редко
     возникают в результате ошибок в программах на Лиспе. Однако, “rarely” и не
     “never”; если ваша программа завершается с ошибкой, которая соответствует
     этому списку, вы можете попытаться изменить этот список, чтобы отладить
     ошибку. Самый простой способ, как правило, чтобы установить
     ‘debug-ignored-errors’ в ‘nil’.

 -- User Option: eval-expression-debug-on-error
     Если эта переменная имеет значение не-'nil' (по умолчанию), выполнив
     команду ‘eval-expression’, ‘debug-on-error’ временно связывается с ‘t’.
     *Note Evaluating Emacs-Lisp Expressions:
     (emacs)Lisp Eval.

     Если ‘eval-expression-debug-on-error’ указывает на ‘nil’, то значение
     ‘debug-on-error’ не изменяется в течении выполнения ‘eval-expression’.

 -- Variable: debug-on-signal
     Как правило, ошибки, пойманные ‘condition-case’ никогда не вызвают отладчик.
     ‘condition-case’ получает шанс обработать ошибку до отладчика.

     Если изменить ‘debug-on-signal’ в значение отличное от ‘nil’, отладчик
     получает первый шанс при каждой ошибке, независимо от наличия
     ‘condition-case’. (Для вызова отладчика, ошибки все равно должны отвечать
     критериям, установленным в ‘debug-on-error’ и ‘debug-ignored-errors’.)

     *Warning:* Установка этой переменной в не-'nil' может иметь раздражающие
     эффекты. Различные части отлавливают ошибки Emacs в нормальном ходе дела,
     и вы можете даже не осознавать, что ошибки случаются там. Если вам нужно
     отладить код, завернутый в ‘condition-case’, следует рассмотреть вопрос об
     использовании ‘condition-case-unless-debug’ (*note Handling Errors::).

 -- User Option: debug-on-event
     Если установить ‘debug-on-event’ в спец режиме(*note Special Events::),
     Emacs будет пытаться войти в отладчик, как только он получает это событие,
     минуя ‘special-event-map’. В настоящее время поддерживаются только значения
     соответствующие сигналам ‘SIGUSR1’ и ‘SIGUSR2’ (по умолчанию). Это может быть
     полезно, когда ‘inhibit-quit’ устанавливается и Emacs иначе не отвечает на
     запросы.

 -- Variable: debug-on-message
     Если установить ‘debug-on-message’ регулярное выражение, Emacs будет вызывать
     отладчик, если отображается соответствующее сообщение в эхо-области. Например,
     это может быть полезно при попытке найти причину конкретного сообщения.

   Для отладки ошибки, которая происходит во время загрузки файла инициализации,
   используйте параметр ‘--debug-init’.  Если связать ‘debug-on-error’ с ‘t’ то
   при загрузке файла инициализации, обходит ‘condition-case’ который обычно ловит
   ошибки в файле инициализации


File: elisp.info,  Node: Infinite Loops,  Next: Function Debugging,  Prev: Error Debugging,  Up: Debugger

17.1.2 Debugging Infinite Loops
-------------------------------

Отладка зацикливания
Когда программа входит в бесконечный цикл и не возвращается, ваша первая
задача, чтобы остановить цикл. В большинстве операционных систем, вы
можете сделать это с помощью 'C-g', что приводит к "quit".  *Note Quitting::.

   Обычные 'quits' не дают никакой информации о том, почему программа была
   зациклена. Для того, чтобы получить более подробную информацию, вы можете
   установить переменную ‘debug-on-quit’ в не-‘nil’. После того, как у вас 
   отладчик запущен в середине бесконечного цикла, вы можете , используя команды,
   пошагово переходить в программе. Если пошагово перейти через весь цикл, можно
   получить достаточно информации, чтобы решить эту проблему.

   Использование Quitting с ‘C-g’ не считается ошибкой, и ‘debug-on-error’ не
   оказывает никакого влияния на обработку 'C-g'. Точно так же, ‘debug-on-quit’
   не оказывает никакого влияния на наличие ошибок.

 -- User Option: debug-on-quit
     Эта переменная определяет, вызывается ли отладчик когда 'quit' сигнализируется
     и не обрабатывается.  Если ‘debug-on-quit’ установлено в не-‘nil’ (по
     умолчанию), то отладчик вызывается всякий раз, когда вы quit (то есть,
     используете 'C-g').

File: elisp.info,  Node: Function Debugging,  Next: Explicit Debug,  Prev: Infinite Loops,  Up: Debugger

17.1.3 Entering the Debugger on a Function Call
-----------------------------------------------

Ввод отладчика на Function Call
Чтобы исследовать проблему, которая происходит в середине программы,один
полезный метод, чтобы войти в отладчик всякий раз, когда некоторая функция
вызывается. Вы можете сделать это в функции, в которой возникает проблема, и
пошагово пройти через функцию, или вы можете войти в функцию исполняющуюся
незадолго до проблемы, быстро перешагнуть вызов этой функции, и войти в
пробленную функцию.

 -- Command: debug-on-entry function-name
     Эта функция запрашивает FUNCTION-NAME для вызова отладчика каждый раз,
     когда функция вызывается.

    Любая функция или макро-определение как лисповской код может быть установлен,
    чтобы разбить на запись, независимо от того, это интерпретируется ли код или
    это скомпилированный код. Если функция является командой, она войдет в
    отладчик при вызове из Lisp и при вызове в интерактивном режиме (после чтения
    аргументов). Можно таким образом также установить debug-on-entry для
    примитивных функций (то есть те, которые написаны на C) , но полезен эффект,
    когда примитив вызывается из кода Lisp. Использование debug-on-entry таким
    образом не допускается для специальных форм.

     Когда ‘debug-on-entry’ вызывается в интерактивном режиме, он запрашивает
     имя-функции в минибуфере. Если функция уже настроен для вызова отладчика на
     входе, ‘debug-on-entry’ ничего не делает. ‘debug-on-entry’ всегда возвращает
     имя-функции.

     Вот пример, чтобы проиллюстрировать использование этой функции:

          (defun fact (n)
            (if (zerop n) 1
                (* n (fact (1- n)))))
               ⇒ fact
          (debug-on-entry 'fact)
               ⇒ fact
          (fact 3)

          ------ Buffer: *Backtrace* ------
          Debugger entered--entering a function:
          * fact(3)
            eval((fact 3))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ------ Buffer: *Backtrace* ------


 -- Command: cancel-debug-on-entry &optional function-name
     Эта функция отменяет эффект ‘debug-on-entry’ для FUNCTION-NAME.
     При вызове в интерактивном режиме, она запрашивает FUNCTION-NAME в
     миннибуфере. Если FUNCTION-NAME опущен или ‘nil’, это отменяет
     break-on-entry для всех функций. Вызов ‘cancel-debug-on-entry’ ничего не
     делает для функции, которая в данный момент не создана, чтобы разорвать на
     входе.


File: elisp.info,  Node: Explicit Debug,  Next: Using Debugger,  Prev: Function Debugging,  Up: Debugger

17.1.4 Explicit Entry to the Debugger
-------------------------------------

Явный вызов в Отладчике
Вы можете вызвать отладчик в определенный момент в вашей программе, написав
выражение '(debug)' в этой точке. Для этого посетите исходный файл, вставте текст
'(debug)' в нужном месте, и используйте ключ ‘C-M-x’ (‘eval-defun’, в лисповском
режим привязки клавиш).  *Warning:* если вы делаете это для целей временной
отладки, не забудьте отменить эту вставку, прежде чем сохранить файл!

   Место, где вы вставите '(debug)' должно быть местом, где дополнительная форма
   может быть оценена и его значение игнорируется. (Если значение '(debug)' не
   игнорируется, это изменит исполнение программы!) Наиболее распространенные
   подходящие места внутри 'progn' или неявном ‘progn’ (*note Sequencing::).

   Если вы не знаете точно, где в исходном коде вы хотите поместить заявление
   отладки, но вы хотите отобразить трассировку, когда отображается определенное
   сообщение, вы можете установить в ‘debug-on-message’ регулярное выражение
   соответствующее нужному сообщению.


File: elisp.info,  Node: Using Debugger,  Next: Debugger Commands,  Prev: Explicit Debug,  Up: Debugger

17.1.5 Using the Debugger
-------------------------

Когда отладчик введен, он отображает ранее выбранный буфер в одном
окне и буфер с именем '* Backtrace *' в другом окне. Буфер трассировку
содержит одну строку для каждого уровня выполнения функции Лиспа в
настоящее время . В начале этого буфера является сообщение с описанием причины,
вызова отладчика (например, сообщения об ошибках и связанных с ними данных,
если был вызван из-за ошибки).

   Буфер трассировки открывается только для чтения и использует специальный
   основной режим, режим отладки, в котором буквы определяются как команды
   отладчика. Обычные команды редактирования Emacs доступны; Таким образом,
   вы можете переключать окна, чтобы исследовать буфер, который был редактируемым
   в момент ошибки, переключать буфера, посещать файлы, или делать любой другой
   вид редактирования. Тем не менее, отладчик позволяет рекурсивно редактировать
   (*note Recursive Editing::) и это имеет смысл вернуться в буфер Backtrace и
   выйти из отладчика (с помощью команды 'q'), когда вы закончите работу с ним.
   Выход из отладчика выходит из рекурсивного редактирования и преключает буфер
   Backtrace. (Вы можете настроить то, что команда 'q' делает с буфером
   Backtrace, установив переменную ‘debugger-bury-or-kill’. Например, установить
   его в "kill", если вы предпочитаете, чтобы убить буфер, а не переключать его.
   Обратитесь к документации переменной для большей информации.)

   Когда отладчик был введен ‘debug-on-error’ переменная временно устанавливается
   в соответствии c ‘eval-expression-debug-on-error’. Если последняя переменная
   не является 'nil ', ‘debug-on-error’ будет временно установлен в 't'. Это
   означает, что любые дальнейшие ошибки, возникающие при выполнении сеанса
   отладки будут (по умолчанию) вызвать другую трассировку. Если это не то, что
   вы хотите, вы можете либо установить ‘eval-expression-debug-on-error’ в ‘nil’,
   или набор ‘debug-on-error’ в ‘nil’ в ‘debugger-mode-hook’.

   Буфер трассировки показывает функции, которые выполняются и их значения
   аргументов. Это также позволяет указать кадр стека, перемещая точку на строку,
   описывающую этот кадр. (Стек кадров является местом, где интерпретатор Лиспа
   записывает информацию о конкретном вызове функции.) Указатель на линии где
   находится точка считается "текущий кадр". Некоторые команды отладчика работают
   на текущем кадре. Если строка начинается со звездой, это означает, что выход
   из кадра будет вызывать отладчик снова. Это полезно для изучения возвращаемого
   значения функции.

   Если имя функции указывается, это означает, что отладчик знает, где его исходный
   код находится. Вы можете щелкнуть мышью по этому имени, или перейти к нему и
   нажав <RET>, чтобы посетить исходный код.

   Сам отладчик должен быть запущен байт-скомпилированным, так как это делает
   видимым о том, сколько кадров стека используются для самого отладчика. Эти
   предположения являются ложными, если отладчик работает интерпретировано.


File: elisp.info,  Node: Debugger Commands,  Next: Invoking the Debugger,  Prev: Using Debugger,  Up: Debugger

17.1.6 Debugger Commands
------------------------

Буфер отладчика (в режиме Debugger) предоставляет специальные команды
в дополнение к обычным Emacs команд. Наиболее важным аспектом
использования команд отладчика является пошаговое изучение кода, так что вы
можете увидеть, потоки управления. Отладчик может пройти через управляющие
структуры интерпретируемых функции, но не может сделать это в byte-compiled функции
Если вы хотели бы пройти через byte-compiled функцию, замените её интерпретируемой
той же функцией. (Для этого, посетите источник для функции и введите 'C-M-x' на
её определении.) Вы не можете использовать пошагово Lisp отладчик для примитивной
функции.

   Ниже приведен список команд режима отладки:

‘c’
     Выход из отладчика и продолжить выполнение. Это возобновляет
     выполнение программы, как если отладчик никогда не был введен (в
     стороне от каких-либо побочных эффектов, которые вызваны изменением
     значений переменных или структур данных, внутри отладчика).

‘d’
     Продолжить выполнение, но войти в отладчик в следующий раз когда Lisp
     функция вызывается. Это позволяет пройти через подвыражения выражений,
     видя, какие значения подвыражения вычисления, и что еще они делают.

     Стек frame для вызова функции, которая входит в отладчик таким образом
     будет помечен автоматически, так что отладчик будет вызываться снова,
     когда кадр завершается. Вы можете использовать 'u' команду, чтобы отменить
     этот флаг.

‘b’
     Отметить как текущий кадр, так что отладчик будет введен, когда кадр
     завершается. Кадры, помеченные таким образом отмечены звездами в
     буфере Backtrace.

‘u’
     Не входить в отладчик, когда текущий кадр завершается. Это отменяет
     'b' команду на этом кадре. Видимый эффект, чтобы удалить звезду из
     строки в буфере Backtrace.

‘j’
     Флаг текущий кадр как 'b'. Затем продолжить выполнение как 'c', но временно
     отключить break-on-entry для всех функций, которые созданы, чтобы сделать
     ‘debug-on-entry’.

‘e’
     Прочитайте лисповское выражение в минибуфере, оценить его (с соответствием
     лексической среде, если это применимо) и выводить значение в эхо-области.
     Отладчик изменяет некоторые важные переменные и текущий буфер, в результате
     своей работы; 'e' временно восстанавливает свои значения вне отладчика, так
     что вы можете просматривать и изменять их. Это делает отладчик более
     прозрачным. В противоположность этому, 'M-:' не делает ничего особенного в
     отладчике; показывает вам значения переменных внутри отладчика.

‘R’
    Как и 'e', но сохранит результат вычисления в буфере ‘*Debugger-record*’.

‘q’
    Прекратить отладку программы; вернуться на верхний уровень выполнения команд
    Emacs.

    Если отладчик был введен из-за 'C-g', и вы действительно хотите quit, а не
    отладку, используйте команду 'q'.

‘r’
     Возвращает значение из отладчика. Значение вычисляется путем считывания
     выражения в минибуфере и оценкой его.

     The ‘r’ команда полезна, когда отладчик был вызван из-за выхода из лисповской
     кадра вызова (в соответствии с нажатием 'b' или введя в кадре 'd'); то
     значение, указанное в команде 'r' используется как значение этого фрейма.
     Это также полезно, если вы вызываете 'debug' и используете возвращаемое
     значение. В противном случае, 'r' имеет тот же эффект, как 'c', и указанное
     возвращаемое значение не имеет значения.

     Вы не можете использовать 'r', когда отладчик был введен из-за ошибки.

‘l’
     Отображение списка функций, которые будут вызывать отладчик при вызове. Это
     список функций, которые установлены, чтобы вызвать отладчик при входе с
     помощью ‘debug-on-entry’.

‘v’
     Включение и отключение отображения локальных переменных текущего кадра стека.


File: elisp.info,  Node: Invoking the Debugger,  Next: Internals of Debugger,  Prev: Debugger Commands,  Up: Debugger

17.1.7 Invoking the Debugger
----------------------------

Вызов отладчика
Здесь мы опишем подробно в полном функцию 'debug', которая используется для
вызова отладчика.

 -- Command: debug &rest debugger-args
     Эта функция входит в отладчик. Переключает буферы в буфер с именем
     ‘*Backtrace*’ (или ‘*Backtrace*<2>’ если это второй рекурсивный вход в
     отладчик и т.д.), и заполняет его информацией о стеке вызовов функции Лиспа.
     Затем он входит в рекурсивное редактирование, показывающее буфер Backtrace в
     режиме отладчика.

     В режиме Debugger ‘c’, ‘d’, ‘j’, и ‘r’ команды выхода из рекурсивного
     редактирования; затем 'debug' переключается обратно в предыдущий буфер и
     возвращается к тому, что называется 'debug'. Это единственный способ,
     чтобы функция 'debug' вернулась к "своему абоненту".

     Использование DEBUGGER-ARGS при ‘debug’ отладкео тображает остаток своих
     аргументов в верхней части '*Backtrace*' буфера, так что пользователь может
     видеть их. За исключением случаев, описанных ниже, это _only_ способ
     использовать эти аргументы.

     Тем не менее, некоторые значения для первого аргумента 'debug' имеют особое
     значение. (Как правило, эти значения используются только внутри Emacs, а не
     программистами, вызывающих 'debug'.) Вот таблица этих специальных значений:

     ‘lambda’
          Первый аргумент ‘lambda’ заставит ‘debug’ вызваться из-за входа в
	  функцию, когда ‘debug-on-next-call’ указывает на не-‘nil’.
	  Отладчик отображает  ‘Debugger entered--entering
          a function:’ в верхней строке части текста буфера

     ‘debug’
          ‘debug’ первый аргумент ‘debug’ означает, что отладчик  был вызван
	  из-за выполнения функции, которая была инструментироавна ​​для отладки
	  на входе. Отладчик отображает строку‘Debugger entered--entering a
          function:’, так же, как в 'lambda' случае. Он также отмечает кадр
	  стека для этой функции, так что она будет ссылаться на отладчик при
	  выходе.

     ‘t’
          Когда первый аргумент 't', то это указывает на вызов 'debug' в связи
	  с оценкой формы вызова функции, когда ‘debug-on-next-call’ связан с
	  не-‘nil’.  Отладчик отображает
	  ‘Debugger entered--beginning evaluation of function call form:’
	  в верхней строке в буфере.

     ‘exit’
          Когда первый аргумент 'exit', это означает выход из кадра стека,
	  ранее отмеченное для вызова отладчика на выходе. Второй аргумент,
	  который передается 'debug' в данном случае это значение, возвращаемое
	  из кадра. Отладчик отображает ‘Debugger entered--returning value:’
	  в верхней строке буфера, с последующим возвращенным значением.

     ‘error’
          Когда первый аргумент 'error', отладчик указывает на то, что в
	  настоящее время введен из-за ошибки или был не обработанный сигнал,
	  показывая ‘Debugger entered--Lisp error:’ после чего сигнал ошибки
	  и любые аргументы ‘signal’.  Для примера,

               (let ((debug-on-error t))
                 (/ 1 0))

               ------ Buffer: *Backtrace* ------
               Debugger entered--Lisp error: (arith-error)
                 /(1 0)
               ...
               ------ Buffer: *Backtrace* ------

         Если был сигнал об ошибке, предположительно, переменная ‘debug-on-error’
	 не-‘nil’. Если был сигнал 'quit', то предположительно переменная
	 ‘debug-on-quit’ не-'nil'.

     ‘nil’
          Используйте 'nil' в качестве первого из DEBUGGER-ARGS, когда вы
	  хотите, чтобы войти в отладчик в явном виде. Остальная часть
	  DEBUGGER-ARGS печатается на верхней строке буфера. Вы можете
	  использовать эту функцию для отображения сообщений, например, чтобы
	  напомнить себе об условиях, при которых 'debug' вызывается.


File: elisp.info,  Node: Internals of Debugger,  Prev: Invoking the Debugger,  Up: Debugger

17.1.8 Internals of the Debugger
--------------------------------

Debugger изнутри
В этом разделе описываются функции и переменные, используемые внутри отладчика.

 -- Variable: debugger
     Значение этой переменной является функция для вызова для вызова отладчика.
     Её значением должна быть функция с любым количеством аргументов, или, более
     типично, название функции. Эта функция должна вызывать какой-то отладчик.
     Значение по умолчанию переменной является 'debug'.

     Первый аргумент, к Lisp функции указывает на то, почему она была вызвана.
     Конвенция аргументов подробно описана в описании 'debug'
     (*note Invoking the Debugger::).

 -- Command: backtrace
     Эта функция печатает вызванные функции Лиспа в данный момент. Эта функция
     используется 'debug', чтобы заполнить '*Backtrace*' буфер. Она написана на C,
     так как она должна иметь доступ к стеку, чтобы определить, какие вызовы
     функций активны. Возвращаемое значение всегда 'nil'.

     В следующем примере выражение Лиспа вызывает ‘backtrace’ (трассировку) в
     явном виде. Это печатает трассировку к потоку ‘standard-output’, который,
     в данном случае, это буфер ‘backtrace-output’.

     Каждая строка трассировки представляет один вызов функции. Строка показывает
     значения аргументов функции, если все они известны; если они все еще
     вычисляются, линия говорит так. Аргументы специальных форм опущены.

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))))))))

               ⇒ (testing nil)

          ----------- Buffer: backtrace-output ------------
            backtrace()
            (list ...computing arguments...)
            (progn ...)
            eval((progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval((with-output-to-temp-buffer ...))
            eval-last-sexp-1(nil)
            eval-last-sexp(nil)
            call-interactively(eval-last-sexp)
          ----------- Buffer: backtrace-output ------------

 -- Variable: debug-on-next-call
     Если её значение не-‘nil’, он говорит, что для вызова отладчика до следующего
     ‘eval’, ‘apply’ или ‘funcall’.  Ввод наборов отладчика
     ‘debug-on-next-call’ в ‘nil’.

     ‘d’ команда в отладчике используется для установки этой переменной.

 -- Function: backtrace-debug level flag
     Эта функция устанавливает debug-on-exit флаг стека frame LEVEL
     уровнем вниз по стеку, придавая ему значение FLAG. Если FLAG не-‘nil’,
     это вызовет отладчик, который необходимо ввести, когда этот кадр позже
     выйдет. Даже нелокальный выход через этот кадр войдет в отладчик.

     Эта функция используется только отладчиком.

 -- Variable: command-debug-status
     Эта переменная записывает состояние отладки текущей интерактивной
     команды. Каждый раз, когда команда вызывается в интерактивном режиме,
     эта переменная связана с 'nil'. Отладчик может установить эту
     переменную, чтобы оставить информацию для будущих вызовов отладчика во
     время того же вызова команды.

     Преимущество использования этой переменной вместо обычной глобальной
     переменной является то, что данные никогда не переносятся на
     последующие вызовы команды.

 -- Function: backtrace-frame frame-number
     Функция ‘backtrace-frame’ предназначена для использования в лисповских
     отладчиках. Она возвращает информацию о том, что вычисление происходит
     в кадре стека FRAME-NUMBER уровнем ниже.

     Если этот кадр не оценивал аргументы еще, или это особая форма,
     значение ‘(nil FUNCTION ARG-FORMS…)’.

     В возвращаемом значении, FUNCTION то, что было обеспечено как CAR
     оцениваемого списка, или выражение ‘lambda’ в случае вызова макроса. Если
     функция имеет ‘&rest’ аргумент, что представляется в виде хвоста списка
     ARG-VALUES.

     Если FRAME-NUMBER находится вне диапазона, ‘backtrace-frame’ возвращает ‘nil’.


File: elisp.info,  Node: Edebug,  Next: Syntax Errors,  Prev: Debugger,  Up: Debugging

17.2 Edebug
===========

Edebug является средством отладки программ Emacs Lisp, с помощью которого вы можете:

   • Пошагово вычислить, останавливаясь перед и после каждого выражения.

   • Установить условные или безусловные точки останова.

   • Останов, когда заданное условие истинно (глобальное событие перерыва).

   • Трассировка медленно или быстро, короткое время остановки в каждой
   точке остановки, или в каждой контрольной точке.

   • Отображение результатов выражения и вычисление выражения, как будто
   снаружи Edebug.

   • Автоматически переоценивать список выражений и отображать их
   результаты каждый раз, когда Edebug обновляет дисплей.

   • Выходные данные трассировки информация о вызовах функций и возврата.

   • Остановка при возникновении ошибки.

   • Показ трассировки, опуская собственные кадры Edebug .

   • Указание оценки аргументов для макросов и определяющих форм.

   • Получить рудиментарные счетчики тестирования охват и частоту.

   Первые три раздела ниже, должны вам сказать достаточно о Edebug, чтобы
   начать использовать его.

* Menu:

* Using Edebug::                Введение в использование Edebug.
* Instrumenting::               Вы должны инструментировать код для того,
  				чтобы отладить его с Edebug.
* Modes: Edebug Execution Modes. Режимы выполнения, останов более или менее часто.
* Jumping::                     Команды для перехода на определенное место.
* Misc: Edebug Misc.            Разные команды.
* Breaks::                      Установка точек останова, чтобы сделать остановку программы.
* Trapping Errors::             Отлов ошибок с Edebug.
* Views: Edebug Views.          Просмотров внутри и за пределами Edebug.
* Eval: Edebug Eval.            Оценка выражения в Edebug.
* Eval List::                   Выражения, значения которых отображаются
       				каждый раз при входе Edebug.
* Printing in Edebug::          Настройка печати.
* Trace Buffer::                Как производить вывод трассировки в буфере.
* Coverage Testing::            Как проверить охват оценки.
* The Outside Context::         Данные, которые Edebug сохраняет и восстанавливает.
* Edebug and Macros::           Указание, как обрабатывать вызовы макросов.
* Options: Edebug Options.      Вариант переменные для настройки Edebug.


File: elisp.info,  Node: Using Edebug,  Next: Instrumenting,  Up: Edebug

17.2.1 Using Edebug
-------------------

Для отладки Lisp программы с Edebug, вы должны сначала "инструментировать"
Лисп код, который вы хотите отладить. Простой способ
сделать это состоит установить точку в определении функции или
макроса, а затем вызвать ‘C-u C-M-x’ (‘eval-defun’ with a prefix argument)
See *note Instrumenting::, альтернативные способы инструментирования кода.

   После того, как функция инструментиррованна, любой вызов функции
активирует Edebug. В зависимости от того, какой режим исполнения
Edebug вы выбрали, активизируя Edebug может остановить выполнение и
пусть вы шаг через функцию, или она может обновить экран и продолжить
выполнение во время проверки для отладки команд. Режим выполнения по
умолчанию шаг, который останавливает выполнение. *Note Edebug Execution Modes::.

   В Edebug, вы обычно рассматриваете буфер Emacs, показывающий источник
отлаживаемого лисповского кода. Это упоминается как "исходный код
буфера" "source code buffer", и он временно только для чтения.

   Стрелка в левом краю указывает на строку, в которой она
выполняется. Точка первоначально показывает, где в строке она
выполняется, но это перестает быть правдой, если вы перемещаете точку
самостоятельно.

   Если инструментировать определения "fac" (как показано ниже), а затем
выполнить '(fac 3)', вот то, что вы обычно видите. Точка находится на
открытой скобкой перед "if".

     (defun fac (n)
     =>★(if (< 0 n)
           (* n (fac (1- n)))
         1))

   Места внутри функции, где Edebug может остановить выполнение
называются "stop points". Они имеют место как до, так и после каждого
подвыражения являющимся списком, а также после каждой переменной в
качестве ссылки. При этом мы используем периоды, чтобы показать точки
останова в функции "fac":

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac .(1- n.).).).
         1).)

   Специальные команды Edebug доступны в буфере с исходным кодом в
дополнение к командам режима Emacs Lisp. Например, можно ввести
команду Edebug <SPC>, чтобы выполнить до следующей точки
останова. Если вы наберете <SPC> сразу же после входа в 'fac', вот
дисплей вы увидите:

     (defun fac (n)
     =>(if ★(< 0 n)
           (* n (fac (1- n)))
         1))

	 Когда Edebug останавливает выполнение после выражения, он отображает
значения выражения в эхо-области.

  Другие часто используемые команды 'b', чтобы установить контрольную
точку в точке останова, 'g', чтобы выполнить до точки останова не
будет достигнута, и 'q' для выхода из Edebug и возврата в цикл команд
верхнего уровня. Команда '?', Чтобы отобразить список всех команд Edebug.


File: elisp.info,  Node: Instrumenting,  Next: Edebug Execution Modes,  Prev: Using Edebug,  Up: Edebug

17.2.2 Instrumenting for Edebug
-------------------------------

	Для того, чтобы использовать Edebug для отладки кода Lisp, вы должны
сначала "инструмент" код. Инструментирование код вставляет
дополнительный код в него, чтобы вызвать Edebug в нужных местах.

  При вызове команды 'C-M-х' ('eval-defun') с преффикс аргументом в
  определении функции, то это инструментирует определение
перед оценкой его. (Это не изменяет сам исходный код.) Если переменная
‘edebug-all-defs’ не является 'nil', что инвертирует значение префикса
аргумента: в этом случае, 'C-M-х' инструментирует определение  _unless_ если 
имеет префикс аргумент. Значение по умолчанию ‘edebug-all-defs’ имеет
значение 'nil'. Команда ‘M-x edebug-all-defs’ переключает значение
переменной ‘edebug-all-defs’.

   Если ‘edebug-all-defs’ не является 'nil ', то команды 'eval-region',
‘eval-current-buffer’, и ‘eval-buffer’ также инструментируют любые определения,
которые они оценивают. Кроме того, средства управления ‘edebug-all-forms’
устанавливает конроль 'eval-region' инструментирования _any_ (любой) формы,
даже не определяющие формы. Это не относится к загрузке или оценок в
минибуфере. Команда 'M-x edebug-all-forms' переключает этот параметр.

   Другая команда , ‘M-x edebug-eval-top-level-form’, делает доступ для
инструментирования любой формы верхнего уровня, независимо от значений
‘edebug-all-defs’ и ‘edebug-all-forms’.  ‘edebug-defun’ является псевдонимом
‘edebug-eval-top-level-form’.

  В то время как Edebug активна, команда инструменты 'I'(‘edebug-instrument-callee’)
определение функции или макро называется формой списка после того, как точки,
если она еще не инструментарована. Это возможно только тогда, когда Edebug знает,
где найти источник для этой функции; По этой причине, после загрузки
Edebug, ‘eval-region’ фиксирует положение каждого определения , даже если не
инструментирует его. Смотрите также команду 'i' (*note Jumping::), какие
шаги следует предпринять в вызов после инструментирование функции.

   Edebug знает, как инструментировать все стандартные специальные формы,
'interactive' формы с выражением аргумента, анонимные
лямбда-выражения и другие определяющие формы. Однако Edebug не может
определить по себе то, что определенный пользователем макрос будет
делать с аргументами вызов макроса, так что вы должны предоставить эту
информацию, используя спецификации Edebug; Для получения
дополнительной информации *note Edebug and Macros::.

   Когда Edebug собирается приборного кода впервые в сессии, она
запускает ловушку ‘edebug-setup-hook’, а затем устанавливает его в
'nil'. Вы можете использовать эту функцию для загрузки спецификаций
Edebug связанных с пакетом, который вы используете, но только тогда,
когда вы используете Edebug.

   Для удаления инструментария из определения, просто вычислить свое
определение таким образом, которое не инструментирует. Есть два способа
оценки формы, которые никогда не инструментируют их: из файла с
'load', и в минибуфере с ‘eval-expression’ (‘M-:’).

   Если Edebug обнаруживает ошибку синтаксиса в то время как
инструментирует, он оставляет точку в ошибочном коде и
сигнализирует об ошибке ‘invalid-read-syntax’.

   *Note Edebug Eval::, для других функций оценки имеющихся внутри Edebug


File: elisp.info,  Node: Edebug Execution Modes,  Next: Jumping,  Prev: Instrumenting,  Up: Edebug

17.2.3 Edebug Execution Modes
-----------------------------

	Edebug поддерживает несколько режимов выполнения для запуска отладки
программы. Мы называем эти альтернативы "Edebug execution modes";
не путайте их с основными или второстепенных режимов. Текущий режим
исполнения Edebug определяет, как далеко Edebug продолжает выполнение
до остановки, остановится-ли он в каждой точке остановки или
продолжит до следующей точки останова, сколько Edebug
отображает ход оценки, прежде чем остановится.

   Как правило, вы определяете режим выполнения Edebug, введя команду для
продолжения программы в определенном режиме. Вот таблица этих команд;
все для исполнения 'S' резюме программы, по крайней мере, на
определенном расстоянии, за исключением.

‘S’
     Stop: не выполнять больше программы, но ждать больше команд
     Edebug(‘edebug-stop’).

‘<SPC>’
     Step: остановится на следующей точке останова (‘edebug-step-mode’).

‘n’
     Next: остановится на следующей точке останова, возникающие после выражения
     (‘edebug-next-mode’).  Подробнее ‘edebug-forward-sexp’ в *note
     Jumping::.

‘t’
     Trace: пауза (обычно одна секунда) в каждой точке остановки Edebug
     (‘edebug-trace-mode’).

‘T’
     Rapid trace: обновить отображение в каждой точке остановки, но на самом
     деле не пауза (‘edebug-Trace-fast-mode’).

‘g’
     Go: не работать до следующей контрольной точки (‘edebug-go-mode’).
     *Note Breakpoints::.

‘c’
     Continue: пауза в одну секунду в каждой контрольной точке, а затем продолжить
     (‘edebug-continue-mode’).

‘C’
     Rapid continue: сдвигает точку к каждой контрольной точке, но не пауза
     (‘edebug-Continue-fast-mode’).

‘G’
     Go non-stop: игнорировать точки останова (‘edebug-Go-nonstop-mode’). Вы все
     еще можете остановить программу, набрав 'S', или любую команду редактирования.


  В общем, режимы выполнения в ранее приведенном выше списке запуска
программы медленнее или остановить раньше, чем режимы в следующем списке.

   При выполнении или трассировки, вы можете прервать выполнение, введя
любую команду Edebug. Edebug останавливает программу в следующей точке
останова, а затем выполняет команду которую вы набрали. Например, при вводе
't' во время выполнения переключателей в режим трассировки в следующей
точке остановки. Вы можете использовать 'S', чтобы остановить
выполнение, не делая ничего другого.

   Если ваша функция происходит для чтения ввода, символ вводимого
текста, намереваясь прервать выполнение может быть считана с помощью
функции вместо этого. Вы можете избежать таких непредвиденных
результатов, обращая внимание, когда ваша программа хочет ввода.

   Клавиатурные макросы, содержащие команды в данном разделе, не
полностью работают: выход из Edebug, чтобы возобновить программу,
теряет возможность отслеживать клавиатуры макроса. Это не легко
исправить. Кроме того, определение или выполнение макрос клавиатуры за
пределами Edebug не влияет на команды внутри Edebug. Это, как правило,
является преимуществом. Смотрите ‘edebug-continue-kbd-macro’ настройка
*note Edebug Options::.

   При вводе нового уровня Edebug, режим начального выполнения происходит
от значения переменной ‘edebug-initial-mode’ (*note Edebug Options::).
По умолчанию этот параметр определяет режим шага. Обратите внимание,
что вы можете повторно ввести тот же уровень Edebug несколько раз,
если, например, инструментированная функция вызывается несколько раз из
одной команды.

 -- User Option: edebug-sit-for-seconds
     Этот параметр определяет, сколько секунд ожидания между шагами
выполнения в режиме трассировки или в режиме продолжения. Значение по
умолчанию 1 секунда.


File: elisp.info,  Node: Jumping,  Next: Edebug Misc,  Prev: Edebug Execution Modes,  Up: Edebug

17.2.4 Jumping
--------------

Команды, описанные в этом разделе выполняться, пока они не достигнут
заданного местоположения. Все, кроме 'i' создать временную контрольную
точку, чтобы установить место для остановки, а затем перейти в режим
идти. Любая другая точка останова достигнута до намеченной точки
остановки будет также останавливать выполнение.
  *Note Breakpoints::, Детальнее о контрольных точках.

   Эти команды могут не работать должным образом в случае нелокального
выхода, так как это может обойти временную контрольную точку, где вы
ожидали остановить программу.


‘h’
     Перейдите к точке останова рядом, где точка (‘edebug-goto-here’).

‘f’
     Запустите программу для одного выражения (‘edebug-forward-sexp’).

‘o’
     Прогоните программу до конца, содержащего sexp
     (‘edebug-step-out’).

‘i’
     Шаг в функцию или макрос, вызываемые формой после точки
     (‘edebug-step-in’).

   ‘h’ переходит к точке остановки в момент или после текущего
местоположения точки, используя временную точку останова.

   The ‘f’ команда запускает программу вперед над одним выражением. Точнее, он
устанавливает временную контрольную точку в позиции, что бы достичь ‘forward-sexp’,
а затем выполняется в режиме идут так, что программа остановится на точки останова.


  С префиксным аргументом N, временная точка прерывания устанавливается
N s-выражения за пределы точки. Если содержащий список заканчивается
до N более элементов, то место для остановки после вмещающего
выражения.

   Вы должны проверить, что положение ‘forward-sexp’ находится в месте, где
   программа сможет действительно добраться . В ‘cond’, например, это может быть
   не так.

   Для гибкости, команда 'F' делает ‘forward-sexp’ начиная с точки, а не в
   точке останова. Если вы хотите, чтобы выполнить одно выражение _from
   текущий стоп point_, первый тип 'w' ('edebug-where'), чтобы переместить
   точку туда, а затем введите 'f'.


   ‘o’ команда продолжает "out of" для выражения. Помещает временную контрольную
точку в конце sexp, содержащей точку. Если содержащее sexp является
само определение функции, 'о' продолжается до тех пор, как раз перед
последним sexp в определении. Если это то, где вы сейчас, она
возвращается из функции, а затем останавливается. Другими словами, эта
команда не выходит из функции исполняемой в данный момент, если вы не
расположены после последнего sexp.

   ‘i’ команда шаги в функцию или макрос, вызываемые формой списка после
точки, и останавливается на своей первой точки остановки. Обратите
внимание, что форма не обязательно должна быть одна о том, чтобы быть
оценены. Но если форма является функцией вызова о том, чтобы оценить,
не забудьте использовать эту команду, прежде чем какой-либо из
аргументов вычисляются, так как в противном случае будет слишком
поздно


   ‘i’ командны инструментировать функцию или макрос, что он должен уйти в, если
он не инструментальными уже. Это удобно, но имейте в виду, что функция
или макрос остается инструментированными, если явно не устроить
deinstrument его.



File: elisp.info,  Node: Edebug Misc,  Next: Breaks,  Prev: Jumping,  Up: Edebug

17.2.5 Miscellaneous Edebug Commands
------------------------------------

Некоторые смешанные команды Edebug описаны здесь.

‘?’
     Отображение сообщения справки для Edebug (‘edebug-help’).

‘C-]’
     Прервать на один уровень назад к предыдущему уровню команды
     (‘abort-recursive-edit’).

‘q’
     Возврат к петле редактор команд верхнего уровня (‘top-level’). Это выходит
     из всех рекурсивных уровней редактирования, включая все уровни активности
     Edebug. Тем не менее, инструментированный код защищен ‘unwind-protect’ и
     ‘condition-case’ формы могут возобновить отладку.

‘Q’
     Как и ‘q’, но не останавливаются даже для защищенного кода
     (‘edebug-top-level-nonstop’).

‘r’
     Перерисовать совсем недавно известный результат экспрессии в
     эхо-области (‘edebug-previous-result’).

‘d’
     Дисплей трассировка, за исключением собственных функций Edebug для ясности
     (‘edebug-backtrace’).

     Вы не можете использовать команды отладчика в буфере Backtrace в
     Edebug, как вы бы в стандартном отладчика.

     Буфер трассировки будет убит автоматически, когда вы продолжите выполнение.

   Вы можете вызывать команды из Edebug, которые активируют Edebug снова
рекурсивно. Всякий раз, когда Edebug активен, вы можете выйти на
верхний уровень используя 'q' или прервать один уровень рекурсивного редактирования
используя ‘C-]’. Вы можете отобразить трассировку всех ожидающих оценки используя
‘d’.


File: elisp.info,  Node: Breaks,  Next: Trapping Errors,  Prev: Edebug Misc,  Up: Edebug

17.2.6 Breaks
-------------

Пошаговый режим Edebug останавливает выполнение при достижении
следующей точки останова. Есть три способа, чтобы остановить
выполнение Edebug после его начала: точки останова, глобальное условие
прерывания, и исходные точки останова.

* Menu:

* Breakpoints::                 Breakpoints в точках останова.
* Global Break Condition::      Ломать на событие.
* Source Breakpoints::          Встраивание в контрольные точки исходного кода.


File: elisp.info,  Node: Breakpoints,  Next: Global Break Condition,  Up: Breaks

17.2.6.1 Edebug Breakpoints
...........................

При использовании Edebug, вы можете указать "breakpoints" в
программе которую вы проверяете: это места, где исполнение должно
остановиться. Вы можете установить точку останова в любой точке
остановки, как определено в *note Using Edebug::. Для включения и отключения
точек останова, точка остановки, пораженной
является первым в момент или после точки в буфере с исходным
кодом. Вот команды Edebug для точек останова:

‘b’
     Установите контрольную точку в точке остановки во время или после точки
     (‘edebug-set-breakpoint’).  Если вы используете префикс аргумент, точка
     останова носит временный характер, она отключается после первой остановки
     в программе.

‘u’
     Отключение точек останова (если таковые имеются) в точке остановки в момент или
     после точки (‘edebug-unset-breakpoint’).

‘x CONDITION <RET>’
     Установка условной точки прерывания, который останавливает программу,
     только если оценка CONDITION вернет значение, отличное от 'nil'
     (‘edebug-set-conditional-breakpoint’).  С префиксным аргументом, точка
     останова носит временный характер.


‘B’
     Переместить точку к следующей контрольной точки в текущем определении
     (‘edebug-next-breakpoint’).

   В то время как в Edebug, вы можете установить контрольную точку используя 'b'
и в одиночном 'u'. Первая точка шаг до остановки точки Edebug
по вашему выбору, а затем введите 'b' или 'u', чтобы установить или
отключить контрольную точку. Уничтожение контрольной точки, где
не установлена ни одна не имеет никакого эффекта.

   Переоценка или reinstrumenting определения удаляет все свои предыдущие
точки останова.

   "conditional breakpoint" проверяет условие, каждый раз, когда программа
   в точке останова. Любые ошибки, возникающие в результате оценки состояния
   игнорируются, как если бы результат был "nil". Чтобы установить условную
   точку останова, используйте 'х', а также указывайте выражение условия в
   минибуфере. Установка условной точки прерывания в точке останова, которая
   имеет ранее установленную условную точку останова переводит предыдущее
   выражение условия в минибуфере, так что вы можете редактировать его.

   Вы можете сделать условные или безусловные точки останова "temporary",
   используя префикс-аргумент с помощью команды, чтобы установить точку останова.
   Когда временная точка останова останавливает программу, она автоматически
   снята с охраны.

   Edebug всегда останавливается или останавливается в контрольной точке,
   за исключением случаев, когда режим Edebug является Go-nonstop. В этом режиме,
   он игнорирует точки останова полностью.

   Для того, чтобы выяснить, где ваши контрольные точки, используйте команду 'B',
   которая перемещает точку к следующей контрольной точки следующей точки, в
   пределах той же функции, или к первой контрольной точке, если нет следующих
   контрольных точек. Эта команда не продолжит выполнение, она просто перемещает
   точку в буфере.


File: elisp.info,  Node: Global Break Condition,  Next: Source Breakpoints,  Prev: Breakpoints,  Up: Breaks

17.2.6.2 Global Break Condition
...............................

 "global break condition" прекращает выполнение, если указанное условие не
 выполнено, независимо от того, где это может произойти. Edebug оценивает
 глобальное состояние разрыва в каждой точке остановки; если он имеет значение
 не- 'nil ', то выполнение останавливается или приостанавливается в зависимости
 от режима исполнения, как если контрольная точка была хитом. При оценке
 состояния получает ошибку, выполнение не останавливается.

   Выражение состояние сохраняется в
‘edebug-global-break-condition’.  Вы можете указать новое выражение с помощью
команды 'X' из буфера исходного кода в то время как Edebug активен, или с
помощью "С-x Х Х" из любого буфера в любое время, до тех пор, как Edebug
загружается (‘edebug-set-global-break-condition’).

   Глобальное условие останова самый простой способ, чтобы найти, где в
   коде какое-то событие происходит, но это делает выполняемый код, гораздо
   медленнее. Таким образом, вы должны сбросить состояние на "nil", когда он
   не используется.


File: elisp.info,  Node: Source Breakpoints,  Prev: Global Break Condition,  Up: Breaks

17.2.6.3 Source Breakpoints
...........................

Все точки останова в определении забывают каждый раз, когда вы reinstrument его.
Если хотите, сделать контрольную точку, которая не будет забыта, можете написать
"source breakpoint", который представляет собой просто вызов функции 'edebug'
в исходном коде. Вы можете, конечно, сделать такой вызов условно. Например, в
'fac' функции, вы можете вставить первую строку, как показано ниже,
чтобы остановить, когда аргумент становится равным нулю:

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

   Когда определение 'fac' является инструментировано и функция вызывается,
   вызов 'edebug' выступает в качестве точки останова. В зависимости от режима
   исполнения, Edebug останавливается или останавливается там.

   Если ни один инструментированный код не выполняется, когда 'edebug' вызывается,
   то функция вызывает 'debug'.



File: elisp.info,  Node: Trapping Errors,  Next: Edebug Views,  Prev: Breaks,  Up: Edebug

17.2.7 Trapping Errors
----------------------

Emacs обычно отображает сообщение об ошибке и сигнализируется об ошибке и не
обрабатывает при 'condition-case'. В то время как Edebug активен и инструментирован
исполняющийся код, он обычно реагирует на все необработанными ошибок. Вы можете
настроить это с помощью опций ‘edebug-on-error’ и ‘edebug-on-quit’;
детальнее *note Edebug Options::.

   Когда Edebug реагирует на ошибки, он показывает последнюю точку останова
   перед ошибкой. Это может быть место вызова функции, которая не была
   инструментирована, и в пределах которой ошибка на самом деле произошлак. Для
   несвязанной переменной ошибки, последняя известная точка останова может быть
   весьма далека от переменной ссылки оскорбительного. В этом случае, вы можете
   захотеть, чтобы отобразить полную трассировку (*note Edebug Misc::).

   Если изменить ‘debug-on-error’ или ‘debug-on-quit’ в то время как Edebug
   активен, эти изменения будут забыты, когда Edebug становится неактивным.
   Кроме того, во время рекурсивного редактирования Edebug эти переменные связаны
   со значениями, которые они имели за пределами Edebug.



File: elisp.info,  Node: Edebug Views,  Next: Edebug Eval,  Prev: Trapping Errors,  Up: Edebug

17.2.8 Edebug Views
-------------------

Эти команды Edebug позволяют просматривать аспекты буфера и окна
статуса, поскольку они были перед входом в Edebug. Конфигурация
снаружи окна представляет собой набор окон и содержания, которые
действовали за пределами Edebug.

‘v’
     Переключение на просмотр конфигурации вне окна
     (‘edebug-view-outside’).  Используйте ‘C-x X w’ для возврата в Edebug.

‘p’
     Временно отобразить внешний текущий буфер с точки на ее внешнем
     положении (‘edebug-bounce-point’), делая паузу в течение одной секунды,
     прежде чем вернуться к Edebug. С префиксным аргументом N, пауза в течение
     N секунд .


‘w’
    Переместить точку назад к текущей точки остановки в буфере с исходным кодом
    (‘edebug-where’).

    Если вы используете эту команду в другом окне отображения один и тот
    же буфер, что окно будет использоваться вместо того, чтобы отобразить
    текущее определение в будущем.

‘W’
     Переключение сохраняет ли Edebug и восстанавливает конфигурацию за
     пределами окна (‘edebug-toggle-save-windows’).

     С префиксным аргументом, 'W' только переключает сохранение и восстановление
     выбранного окна. Чтобы указать окно, которое не показывает буфер исходного
     кода, вы должны использовать 'C-x X W' от глобальной раскладки.

   Вы можете просмотреть конфигурацию вне окна нажав 'v' или просто перейти до
   точки в текущем буфере используя 'р', даже если он не отображается нормально.

   После перемещения точки, вы можете перейти обратно к точке остановки. Вы
   можете сделать это нажав 'w' из буфера исходного кода. Вы можете перейти
   обратно в точку останова в буфере исходного кода из любого буфера с помощью
   'C-x X w'.

  Каждый раз, когда вы используете 'W', чтобы включить опцию _off_, Edebug забывает
  спасенных вне окна конфигурации, так что даже если вы поворачиваете экономить
  обратно _on_, текущая конфигурация окна остается неизменным при следующем
  выходе Edebug (продолжая программу). Тем не менее, автоматическое обновление
  дисплея '*edebug*' и '*edebug-trace*' может вступать в противоречие с буферами,
  которые вы хотите видеть, если у вас нет достаточного количества открытых окон.


File: elisp.info,  Node: Edebug Eval,  Next: Eval List,  Prev: Edebug Views,  Up: Edebug

17.2.9 Evaluation
-----------------

В то время как в рамках Edebug, вы можете вычислять выражения, как
будто Edebug не были запущены. Edebug старается быть невидимым для
оценки и печати выражения. Оценка выражений, которые вызывают побочные
эффекты будут работать, как и следовало ожидать, для изменения данных,
которые Edebug явно сохраняет и восстанавливает за исключением.
*Note The Outside Context::, для получения дополнительной информации по этому
процессу.

‘e EXP <RET>’
     Оценка экспрессии EXP в контексте за пределами Edebug
     (‘edebug-eval-expression’).То есть, Edebug пытается минимизировать свое
     вмешательство с оценкой.

‘M-: EXP <RET>’
     Оценка экспрессии EXP в контексте самого Edebug
     (‘eval-expression’).

‘C-x C-e’
     Вычислить выражение перед точкой, в контексте за пределами Edebug
     (‘edebug-eval-last-sexp’).

   Edebug поддерживает оценку выражений, содержащих ссылки на лексически
связанных символов, созданных с помощью следующих конструкций в ‘cl.el’:
‘lexical-let’, ‘macrolet’, ‘symbol-macrolet’.


File: elisp.info,  Node: Eval List,  Next: Printing in Edebug,  Prev: Edebug Eval,  Up: Edebug

17.2.10 Evaluation List Buffer
------------------------------

Вы можете использовать "evaluation list buffer", под названием '*edebug*', для
вычисления выражений в интерактивном режиме. Вы также можете создать
"evaluation list" выражений, которые будут оцениваться автоматически каждый раз,
когда Edebug обновляет дисплей.

‘E’
     Переключение в буфер списка оценки ‘*edebug*’
     (‘edebug-visit-eval-list’).

   ‘*edebug*’ буфер можно использовать команды режима Lisp Interaction
   (*note (emacs)Lisp Interaction::) а также эти специальные команды:

‘C-j’
	Вычислить выражение перед точкой, во внешнем контексте, и вставить
	значение в буфере (‘edebug-eval-print-last-sexp’).

‘C-x C-e’
     Вычислить выражение перед точкой, в контексте за пределами
     Edebug (‘edebug-eval-last-sexp’).

‘C-c C-u’
     Построить новый список оценки из содержимого буфера
     (‘edebug-update-eval-list’).

‘C-c C-d’
     Удаление списка оценки группы, которая находится точка
     (‘edebug-delete-eval-item’).

‘C-c C-w’
     Переключитесь обратно в буфер исходного кода в текущей точке останова
     (‘edebug-where’).

   Вы можете оценить выражения в окне списка оценки используя ‘C-j’ и ‘C-x C-e’,
   так же как и в ‘*scratch*’; но они оцениваются в контексте за пределами Edebug.

   Выражения вы вводите в интерактивном режиме (и их результаты) теряются, когда
   вы продолжаете выполнение; но вы можете создать "evaluation list", состоящий
   из выражений, которые будут оцениваться каждый раз, когда выполнение
   останавливается.

   Для этого нужно написать один или несколько "evaluation list groups" в буфере
   списка оценки. Группа оценочный список состоит из одного или нескольких Lisp
   выражений. Группы разделены строками комментариев.

   Команда ‘C-c C-u’ (‘edebug-update-eval-list’) перестраивает оценочный список,
   сканирование буфера и с использованием первого экспрессии каждой группы.
   (Идея заключается в том, что второе выражение группы является значение ранее
   вычисленных и отображается.)

   Каждая запись в Edebug перерисовывает список оценки путем вставки каждого
   выражения в буфере, а затем его текущее значение. Он также вставляет строки
   комментариев, так что каждое выражение становится своей собственной группой.
   Таким образом, если вы использовали 'С-с С-u'снова без изменения текста буфера,
   оценочный список останется фактически без изменений.

   При возникновении ошибки во время оценки списка оценки,отображается сообщение
   об ошибке в строку, как если бы это было результатом. Таким образом, выражения,
   использующие переменные, которые в настоящее время не действует, не прерывать
   отладку.

   Вот пример того, как окно списка оценки выглядит как после того, как несколько
   выражений, которые были добавлены к нему:

     (current-buffer)
     #<buffer *scratch*>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on *scratch*>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

   Чтобы удалить группу, переместить точку в нее и используйте ‘C-c C-d’, или
   просто удалить текст для группы и обновить список оценки ‘C-c C-u’. Чтобы
   добавить новое выражение в список оценки, вставить выражение в подходящем месте,
   вставьте новую строку комментария, а затем введите ‘C-c C-u’. Вам не нужно
   вставлять дефис в строке комментария, его содержание не имеет значения.

   После выбора '*edebug*', вы можете вернуться к коду буфера источника 'С-c С-w'.
   '*Edebug*' буфер будет убит, когда вы продолжете выполнение, и воссоздан в
   следующий раз при необходимости.


File: elisp.info,  Node: Printing in Edebug,  Next: Trace Buffer,  Prev: Eval List,  Up: Edebug

17.2.11 Printing in Edebug
--------------------------

Если выражение в вашей программе производит значение, содержащее кольцевую
структуру списка, вы можете получить сообщение об ошибке при попытке Edebug
напечатать его.

   Один из способов справиться с круговой структурой, установить ‘print-length’
   или ‘print-level’ усечь печать. Edebug делает это для вас; он связывает
   ‘print-length’ и ‘print-level’ со значениями переменных ‘edebug-print-length’
   и ‘edebug-print-level’ (такими которыми они есть non-‘nil’ значениями).
   *Note Output Variables::.

 -- User Option: edebug-print-length
     Если не -‘nil’, Edebug связывает ‘print-length’ к этому значению при печати
     результатов. Значение по умолчанию '50'.

 -- User Option: edebug-print-level
     Если не -‘nil’, Edebug связывает ‘print-level’ к этому значению в процессе
     печати результатов. Значение по умолчанию '50'.

   Можно также печатать кольцевые структуры и структуры, которые разделяют
   элементы более информативно путем связывания 'print-circle' отличного от 'nil'
   значения.

   Ниже приведен пример кода, который создает круговую структуру:

     (setq a '(x y))
     (setcar a a)

Пользовательская настройка печати печатает это как ‘Result: #1=(#1# y)’.
‘#1=’ обозначение маркирует структуру, которая следует за ней с меткой ‘1’, и
‘#1#’ обозначение ссылается на ранее помеченную структуру. Это обозначение
используется для каких-либо общих элементов списков или векторов.

 -- User Option: edebug-print-circle
     Если на -‘nil’, Edebug связывает ‘print-circle’ к этому значению в процессе
     печати результатов. Значение по умолчанию ‘t’.

   Другие программы могут также использовать пользовательские печати; смотри
   ‘cust-print.el’ для деталей.


File: elisp.info,  Node: Trace Buffer,  Next: Coverage Testing,  Prev: Printing in Edebug,  Up: Edebug

17.2.12 Trace Buffer
--------------------

Edebug может записать трассировки выполнения, сохраняя его в буфер с именем
‘*edebug-trace*’. Это журнал вызовов функций и возвращается, показывая имена
функций и их аргументы и значения. Чтобы включить запись трассировки, установите
 ‘edebug-trace’ отличное от -‘nil’ значение.

   Создание буфера трассировки не то же самое, что использовать режим выполнения
   трассировки (*note Edebug Execution Modes::).

   При включенной записи трассировки , каждый вход в функцию и выход добавляет
   строки в буфер трассировки. Запись вход в функцию состоит из ':::: {', за которым
   следует имя функции и значения аргументов. Запись выхода из функции состоит из
   '::::}', за которым следует имя функции и результат функции.

   Количество символов ':' в записи показывает свою глубину рекурсии. Вы можете
   использовать скобки в буфере трассировки, чтобы найти начало или конец
   сопоставления вызовов функций.

   Вы можете настроить запись трассировки для входа и выхода функции,пересматривая
   функции ‘edebug-print-trace-before’ и ‘edebug-print-trace-after’.

 -- Macro: edebug-tracing string body…
     Этот макрос запрашивает дополнительную информацию трассировки вокруг
     выполнения форм BODY. Аргумент STRING определяет текст поместить в буфер
     трассировки, после того, как ‘{’ or ‘}’.  Все аргументы оцениваются и
     ‘edebug-tracing’ возвращает значение последней формы в BODY.

 -- Function: edebug-trace format-string &rest format-args
     Эта функция вставляет текст в буфер трассировки. Он вычисляет текст с
      ‘(apply 'format FORMAT-STRING FORMAT-ARGS)’.  Он также добавляет символ
      новой строки в отдельные записи.

   ‘edebug-tracing’ и ‘edebug-trace’ вставят строки в буфере трассировки всякий
   раз, когда они вызываются, даже если Edebug не активен. Добавление текста в
   буфер трассировки также прокручивает его окно, чтобы показать последние
   вставленные строки.


File: elisp.info,  Node: Coverage Testing,  Next: The Outside Context,  Prev: Trace Buffer,  Up: Edebug

17.2.13 Coverage Testing
------------------------

Edebug обеспечивает элементарное тестирование покрытия и отображение
частоты выполнения.

Тестирование покрытия работает путем сравнения результата каждого
выражения с предыдущим результатом; каждая форма в программе считается
"covered" (покрыт), если она вернула два различных значения, так как вы начали
охват тестирования в текущем сеансе Emacs. Таким образом, чтобы сделать
тестирование покрытия на вашей программе, выполнить его в различных условиях и
обратите внимание, ведет ли оно правильно; Edebug сообщит вам, когда вы
попробовали достаточно разные условия, и каждая форма вернула два различных
значения.

   Тестирование покрытия делает выполнение медленнее, так что это делается только
   если ‘edebug-test-coverage’ отлично от ‘nil’. Подсчет частоты выполняется для
   всех выполнений инструментованной функции, даже если режим выполнения является
   Go-nonstop, и независимо от того, включено ли тестирование покрытия.

   Используй ‘C-x X =’ (‘edebug-display-freq-count’) чтобы отобразить информацию
   для охвата и подсчета частот для определения. Просто ‘=’
   (‘edebug-temp-display-freq-count’) отображает ту же информацию, временно,
   только до тех пор, пока введёте другой ключ.

 -- Command: edebug-display-freq-count
     Эта команда отображает данные подсчета частоты для каждой строки
     текущего определения.

     Она вставляет подсчет частоты, как строки комментариев после каждой
     строки кода. Вы можете отменить все вставки одной командой 'undo'. Подсчеты
     появляются под '(' перед выражением или ')' после выражения, или на
     последний символ переменной. Для упрощения отображения, отсчет не
     отображается, если оно равно количеству более раннего выражения в той же
     строке.

     Символ '=' после подсчета для выражения говорит, что выражение вернулось
     то же значение каждый раз, когда она была оценена. Другими словами, это
     еще не "covered"  для целей тестирования покрытия.

     Чтобы очистить данные подсчета частоты и охвата для определения,
     просто reinstrument его ‘eval-defun’.

   Например, после оценки '(fac 5)' с исходной точки останова, и установка
   ‘edebug-test-coverage’ to ‘t’, при достижении точки останова, данные частоты
   выглядят следующим образом:

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      = =5
       (if (< 0 n)
     ;#5         =
           (* n (fac (1- n)))
     ;#    5               0
         1))
     ;#   0

   В строки комментария показывают, что 'fac' была вызвана 6 раз. Первый 'if'
   заявление возвращено 5 раз с тем же результатом каждый раз; то же самое можно
   сказать о состоянии на втором 'if'. Рекурсивный вызов 'fac' не вернулся вообще.



File: elisp.info,  Node: The Outside Context,  Next: Edebug and Macros,  Prev: Coverage Testing,  Up: Edebug

17.2.14 The Outside Context
---------------------------

Edebug пытается быть прозрачным для отлаживаемой программы, но это не
удается полностью. Edebug также пытается быть прозрачным, когда вы
вычислять выражения с 'е' или с буфером списка оценки, путем
временного восстановления вне контекста. В этом разделе объясняется,
что именно контекст восстанавливает Edebug, и как Edebug не может быть
полностью прозрачным.

* Menu:

* Checking Whether to Stop::    Когда Edebug решает, что делать.
* Edebug Display Update::       Когда Edebug обновляет экран.
* Edebug Recursive Edit::       Когда Edebug прекращает выполнение.


File: elisp.info,  Node: Checking Whether to Stop,  Next: Edebug Display Update,  Up: The Outside Context

17.2.14.1 Checking Whether to Stop
..................................

Всякий раз, когда Edebug введен, он должен сохранять и восстанавливать
определенные данные, прежде чем даже решить, следует ли предоставлять
информацию трассировки или остановить программу.

   • ‘max-lisp-eval-depth’ и ‘max-specpdl-size’ оба увеличены, чтобы уменьшить
   влияние Edebug в стек. Можно, однако, по-прежнему работать из стека при
   использовании Edebug.

   • Состояние клавиатуры выполнения макроса сохраняется и восстанавливается. В
   то время как Edebug активен, ‘executing-kbd-macro’ установленно в ‘nil’ пока
     ‘edebug-continue-kbd-macro’ отлично от -‘nil’.


File: elisp.info,  Node: Edebug Display Update,  Next: Edebug Recursive Edit,  Prev: Checking Whether to Stop,  Up: The Outside Context

17.2.14.2 Edebug Display Update
...............................

Когда Edebug необходимо отобразить что-то (например, в режиме трассировки), он
сохраняет текущую конфигурацию окна из “outside” Edebug (*note Window
Configurations::).  При выходе из Edebug, восстанавливает предыдущую
конфигурацию окна.

   Emacs перерисовывает только тогда, когда он делает паузу. Обычно, когда вы
   продолжаете выполнение, программа повторно входит Edebug в контрольной точке
   или после ухода, без приостановки или чтение входных данных между ними. В
   таких случаях Emacs никогда не получает шанс перерисовать 'outside'
   конфигурации. Следовательно, то, что вы видите ту же конфигурацию окна, как
   в последний раз Edebug был активен, без перерыва.

   Вход в Edebug для отображения что-то также сохраняет и восстанавливает
   следующие данные (хотя некоторые из них намеренно не восстанавливаются,
   если ошибка или выхода сигнала происходит).

   • Какой буфер, позиции точки и метки в текущем буфере, сохраняются и
   восстанавливаются.

   • Конфигурация снаружи окна сохраняется и восстанавливается, если
     ‘edebug-save-windows’ отлично от -‘nil’ (*note Edebug Options::).

     Конфигурация окна не восстанавливается в случае ошибки или quit, но за
     пределами выбранного окна _is_ даже на повторном выборе ошибки или quit в
     случае 'save-excursion' активна. Если значение ‘edebug-save-windows’
     список, только перечисленные окна будут сохранены и восстановлены.

     Начало окна и горизонтальная прокрутка буфера исходного кода не
     восстанавливаются, однако, таким образом, что дисплей остается
     когерентным в пределах Edebug.

   • Значение точки в каждом из отображаемого буфера сохраняется и
   восстанавливается, если ‘edebug-save-displayed-buffer-points’ не -‘nil’.

   • Переменные ‘overlay-arrow-position’ и ‘overlay-arrow-string’
     сохраняются и восстанавливаются, так что вы можете смело ссылаться на
     Edebug из рекурсивного редактирования в другом месте в том же буфере.

   • ‘cursor-in-echo-area’ локально привязан к 'nil', чтобы курсор отображался
   в окне.



File: elisp.info,  Node: Edebug Recursive Edit,  Prev: Edebug Display Update,  Up: The Outside Context

17.2.14.3 Edebug Recursive Edit
...............................

Когда Edebug вводится и на самом деле читает команды от пользователя,
он сохраняет (а затем восстанавливает) эти дополнительные данные:

   • Текущие данные выполнения.  *Note Match Data::.

   • Переменные ‘last-command’, ‘this-command’, ‘last-command-event’,
     ‘last-input-event’, ‘last-event-frame’, ‘last-nonmenu-event’, и
     ‘track-mouse’.Команды в Edebug не влияют на эти переменные за пределами Edebug.

     Выполнение команд в Edebug может изменить последовательность клавиш,
     что было бы возвращено ‘this-command-keys’, и нет никакого способа, чтобы
     сбросить последовательность клавиш из Лиспа.

    Edebug не может сохранять и восстанавливать значения
     ‘unread-command-events’. Ввод Edebug в то время как эта переменная имеет
     нетривиальное значение может помешать исполнению отлаживаемой программы.

   • Сложные команды, выполняемые в то время как в Edebug добавляются к переменной
     ‘command-history’. В редких случаях это может изменить выполнение.

   • В Edebug, глубина рекурсии появляется один глубже, чем глубина рекурсии
   за пределами Edebug. Это не относится к автоматически обновляемого окна
   списка оценки.

   • ‘standard-output’ и ‘standard-input’ связывает обязательно с ‘nil’ сама
     ‘recursive-edit’, но Edebug временно восстанавливает их во время оценки.

   • Состояние клавиатуры определения макроса сохраняется и восстанавливается.
   В то время как Edebug активен, ‘defining-kbd-macro’ связан с
     ‘edebug-continue-kbd-macro’.


File: elisp.info,  Node: Edebug and Macros,  Next: Edebug Options,  Prev: The Outside Context,  Up: Edebug

17.2.15 Edebug and Macros
-------------------------

Для того, чтобы должным образом Edebug инструментировал выражения, которые
вызывают макросы, некоторым требуется уделять особое внимание. В данном
подразделе описаны детали.

* Menu:

* Instrumenting Macro Calls::   Основные проблемы.
* Specification List::          Как определить сложные схемы оценки.
* Backtracking::                Что Edebug делает, когда сравнение оказалось неуспешным.
* Specification Examples::      Чтобы понять спецификации.


File: elisp.info,  Node: Instrumenting Macro Calls,  Next: Specification List,  Up: Edebug and Macros

17.2.15.1 Instrumenting Macro Calls
...................................

Когда Edebug инструментирует выражение, которое вызывает лисповский
макрос, он нуждается в дополнительной информации о макросе, чтобы
сделать работу правильно. Это происходит потому, что нет априори
способ сказать, какие подвыражения вызова макроса являются формами,
которые будут оценены. (Оценка может происходить непосредственно в
теле макрокоманды, или когда в результате расширения оценивается, или
позже в любое время.)

   Таким образом, вы должны определить спецификацию Edebug для каждого
макроса, с которым Edebug столкнется, чтобы объяснить формат обращений в
этот макрос. Чтобы сделать это, добавьте 'debug' декларацию в
макроопределении. Вот простой пример, который показывает спецификацию
для 'for' примера макроса (*note Argument Evaluation::).

     (defmacro for (var from init to final do &rest body)
       "Выполнение простой \"for\" петли.
     Для примера, (for i from 1 to 10 do (print i))."
       (declare (debug (symbolp "from" form "to" form "do" &rest form)))
       ...)

   Спецификация Edebug говорит, какие части вызова макроса являются
формами, которые будут оценены. Для простых макросов, спецификация
часто выглядит очень похоже на формальный список аргументов
макроопределении, но технические характеристики являются гораздо более
общими, чем список макро-аргументов. *Note Defining Macros::, для более подробного
объяснения 'declare' формы .

   Убедитесь, что технические характеристики известны Edebug, когда вы
   инструментируете код. Если вы инструментировали функцию из файла, которая
   использует ‘eval-when-compile’ требуя другой файл, содержащий определения
   макросов, вам может понадобиться явно загрузить файл.

   Можно также определить спецификацию edebug для макроса отдельно от
макроопределения используя ‘def-edebug-spec’.  Добавление объявлений 'debug'
является предпочтительнее, и более удобными, для макроопределений Лиспа, но
‘def-edebug-spec’ позволяет определить характеристики Edebug для специальных
форм, реализованных в C.

 -- Macro: def-edebug-spec macro specification
     Укажите, какие выражения макровызова MACRO формы должны быть
     оценены.  SPECIFICATION должна быть спецификация edebug. Ни один аргумент
     не вычисляется.

     Аргумент MACRO может быть на самом деле какой-нибудь символ, а не
     только имя макроса.

   Ниже приведена таблица возможностей для SPECIFICATION и, как каждый
   направляет обработку аргументов.


‘t’
     Все аргументы инструментированы для оценки.

‘0’
     Ни один из аргументов не является инструментарованы.

a symbol
     Символ должен указывать на спецификацию Edebug. Это исполнение повторяется
     до тех пор пока другого рода спецификации не будет найдены. Это позволяет
     наследовать спецификацию от другого макроса.

a list
     Элементы списка описывают типы аргументов формы вызова. Возможные элементы
     списка спецификации описаны в следующих разделах.

   Если макрос не имеет спецификации Edebug, ни через 'debug' декларации, ни через
   использование ‘def-edebug-spec’ , переменная ‘edebug-eval-macro-args’
   вступает в игру.

 -- User Option: edebug-eval-macro-args
     Контролирует путь где Edebug рассматривает аргументы макросов, без явной
     спецификации Edebug. Если это 'nil' (по умолчанию), ни один из аргументов
     не является инструментарием для оценки. В противном случае все аргументы
     являются инструментарием.

File: elisp.info,  Node: Specification List,  Next: Backtracking,  Prev: Instrumenting Macro Calls,  Up: Edebug and Macros

17.2.15.2 Specification List
............................

"specification list" требуется для спецификации Edebug если некоторые аргументы
вызов макроса вычисляются, а другие нет. Некоторые элементы в списке спецификации
соответствуют одному или нескольким аргументам, а другие изменяют обработку всех
следующих элементов. Последние называют "specification keywords", символы,
начинающиеся с ‘&’ (такие как ‘&optional’).

    Список спецификации может содержать подсписки, которые соответствуют
    аргументам, которые сами являются списками, или он может содержать векторы,
    используемые для группировки. Подсписки и группы, таким образом, подразделяют
    список спецификации в иерархии уровней. Спецификация ключевых слов применяются
    только к остатку подсписка или группы.

   Когда список спецификации включает в себя альтернативы или повторение,
   соответствие его против фактического вызова макроса может потребовать откаты.
   Больше подробностей, *note Backtracking::.

   Характеристики Edebug обеспечивают мощность регулярных выражений, а также
   некоторую контекстно-свободную грамматику конструкций: сращивание с подсписков
   сбалансированных скобок, рекурсивной обработки форм и рекурсии с помощью
   косвенных характеристик.
   Вот таблица возможных элементов списка спецификаций, с их значениями
   (see *note Specification Examples::, для ссылочных примеров):

‘sexp’
     Один невычисленный Лисп объект, который не инструментарован.

‘form’
     Одно вычисляемое выражение, которое инструментировано.

‘place’
     Обобщенная переменная.  *Note Generalized Variables::.

‘body’
     Короче для ‘&rest form’.  Подробнее ‘&rest’ ниже.

‘function-form’
     Функция формы: либо квотитрованная функция символа, в кавычках
     лямбда-выражение, или форма (что следует оценивать в символ функции
     или лямбда-выражения). Это полезно, когда аргумент, это лямбда-выражение
     которое может быть заключено в кавычки с 'quote', а не 'function', каким
     либо образом инстументирована в теле лямбда-выражением.

‘lambda-expr’
     Лямбда-выражение не цитировать.

‘&optional’
     Все следующие элементы в списке спецификации не являются обязательными;
     как только одно не соответствует, Edebug отключает соответствие на этом уровне.
     Для того, чтобы сделать всего несколько элементов, необязательно, с
     последующим без дополнительных элементов, используйте ‘[&optional SPECS…]’.
     Чтобы указать, что некоторые элементы должны совпадать или нет, используйте
     ‘&optional [SPECS…]’. Смотрите 'defun' пример.

‘&rest’
     Все следующие элементы в списке спецификации повторяются ноль или более раз.
     В последнем повторе, тем не менее, это не является проблемой, если выражение
     кончалось до согласования всех элементов списка спецификаций.
     Чтобы повторить только несколько элементов, используйте ‘[&rest SPECS…]’.
     Чтобы указать несколько элементов, которые должны совпадать на каждом
     повторения, используйте ‘&rest [SPECS…]’.

‘&or’
     Каждый из следующих элементов в списке спецификации является альтернативой.
     Однин из альтернатив должен совпасть, или '&or' спецификация терпит неудачу.

     Каждый элемент списка следующие за '&or' является одной альтернативой. Для
     того, чтобы сгруппировать два или более элементов списка в качестве одной
     альтернативы, нужно вложить их в '[...]'.

‘&not’
     Каждая из следующих элементов подобран в качестве альтернативы, как будто
     с помощью '&or', но если какой-либо из них совпадает, спецификация терпит
     неудачу. Если ни один из них не совпадают, ничего не соответствует, тогда
     '&not' спецификация завершается успешно.

‘&define’
     Указывает, что спецификация для определления формы. Определяющая форма сама
     по себе не инструментирована (то есть, Edebug не останавливается до и после
     того, как определяет форму), но формы внутри него, как правило, будут
     инструментальными. '&defun' ключевое слово должно быть первым элементом
     в спецификации списка.

‘nil’
     Успешно, когда нет больше аргументов, чтобы соответствовать на текущем
     уровне списка аргументов; в противном случае нет. См подсписки
     спецификации и обратного апострофа пример.

‘gate’
     Ни один аргумент не соответствует, но возврат через проход отключается
     во время согласования оставшейся части спецификации на этом уровне. Это в
     первую очередь используется для создания более конкретных сообщений об
     ошибках синтаксиса. See *note Backtracking::, для деталей.  Смотри также
     ‘let’ пример.

‘OTHER-SYMBOL’
     Любой другой символ в списке спецификаций может быть предикат или
     косвенное указание.

     Если символ имеет спецификацию Edebug, "indirect specification" должна быть
     либо спецификации список, который используется вместо символа, или функция,
     которая вызывается для обработки аргументов. Спецификация может быть
     определена ‘def-edebug-spec’ так же, как для макросов. Смотрите 'defun'пример.

     В противном случае символ должен быть предикат. Предикат вызывается с
     аргументом, и если предикат возвращает 'nil', спецификация терпит неудачу,
     и аргумент не инструментируется.

     Некоторые подходящие предикаты включают ‘symbolp’, ‘integerp’, ‘stringp’,
     ‘vectorp’, и ‘atom’.

‘[ELEMENTS…]’
     Вектор элементов групп элементов в единую "group specification". Его
     значение не имеет ничего общего с векторами.

‘"STRING"’
     Аргумент должен быть символом имени STRING. Эта спецификация эквивалентна
     цитируемого символу, ‘'SYMBOL’, где название SYMBOL является строка,
     предпочтительной формой строки.

‘(vector ELEMENTS…)’
     Аргумент должен быть вектор, элементы которого должны соответствовать
     ELEMENTS в спецификации. Смотрите пример обратного апострофа.

‘(ELEMENTS…)’
     Любой другой список является "sublist specification" и аргумент должен быть
     списком, элементы которого соответствуют спецификации ELEMENTS.

     Подсписок спецификация может быть пунктирный список или соответствующий
     список аргументов может быть затем пунктирный список. В качестве альтернативы,
     последний CDR из пунктирной спецификации список может быть другой подсписок
     спецификации (через группировку или косвенную спецификацию, например,
     ‘(spec . [(more specs…)])’), элементы которого соответствуют не-пунктирные
     аргументы списка. Это полезно в рекурсивных спецификациях, таких, как в
     примере обратного апострофа. Также смотрите описание 'nil' спецификации
     выше для прекращения такой рекурсии.

     Обратите внимание, что спецификация подсписком записывается как
     ‘(specs . nil)’ эквивалентно ‘(specs)’,и ‘(specs . (sublist-elements…))’
     эквивалентно ‘(specs sublist-elements…)’.

   Ниже приведен список дополнительных спецификаций, которые могут появиться
   только после ‘&define’.  смотри ‘defun’ пример.

‘name’
     Аргумент, символ, это имя определяющего форму.

     Определяющая форма не требуется иметь имя поля; и  может иметь
     несколько полей имен.

‘:name’
     Эта конструкция фактически не соответствует аргументу. Элемент,следующий
     за ‘:name’ должен быть символом; он используется в качестве дополнительного
     компонента имени для определения. Вы можете использовать это, чтобы добавить
     уникальный, статический компонент с именем определения. Он может быть
     использован более чем один раз.

‘arg’
     Аргумент, символ, это имя аргумента определяющего форму. Тем не менее,
     лямбда-список ключевых слов (символы, начинающиеся с '&') не допускаются.

‘lambda-list’
     Это соответствует лямбда-список список аргументов лямбда-выражения.

‘def-body’
     Аргумент тело кода в определении. Это как 'body', описанной выше, но
     тело определение должно быть инструментировано с другим Edebug вызова,
     который просматривает информацию, связанную с определением. Используйте
     ‘def-body’ для самого высокого уровня списка форм в рамках определения.

‘def-form’
     Аргумент представляет собой единый, высшего уровня формы в определении.
     Это как ‘def-body’, за исключением того, что используется для согласования
     единой формы, а не список форм. Как частный случай, ‘def-form’также означает,
     что отслеживание информации не выводится, когда форма выполняется.
     Смотрите 'interactive' пример.


File: elisp.info,  Node: Backtracking,  Next: Specification Examples,  Prev: Specification List,  Up: Edebug and Macros

17.2.15.3 Backtracking in Specifications
........................................

Если спецификация не совпадает в какой-то момент, это не обязательно
означает, что ошибка синтаксиса будет сигналом; вместо этого,
"backtracking" будет проходить до тех пор, пока все альтернативы были
исчерпаны. В конце концов, каждый элемент списка аргументов должен
быть согласован с помощью какого-либо элемента в спецификации, и
каждый обязательный элемент в спецификации должен соответствовать
некоторый аргумент.

   При обнаружении ошибки синтаксиса, он не может быть сообщено
значительно позже, после того, как альтернативы более высокого уровня,
были исчерпаны, и с точкой, расположенной дальше от реальной
ошибки. Но если перебором отключается при возникновении ошибки, можно
сообщить немедленно. Обратите внимание, что откаты также автоматически
снова включается в нескольких ситуациях; когда новая альтернатива
устанавливается '&optional', '&rest', или '&or', или в начале обработки подсписка,
группы или косвенной спецификации. Эффект включения или отключения обратного
отслеживания ограничивается оставшейся частью уровня обрабатываемой в данный
момент и более низкие уровни.

   Откат отключается во время согласования любой из спецификаций формы
   (то есть, ‘form’, ‘body’, ‘def-form’, и ‘def-body’). Эти характеристики
   будут соответствовать любой формы так что любая ошибка должна быть в самой
   форме, а не на более высоком уровне.

Откат также отключается после успешного согласования котируемой символа или
строки спецификации, так как это обычно указывает на признанную конструкцию.
Но если у вас есть набор альтернативных конструкций, которые начинаются с того
же символа, как правило, можно обойти это ограничение факторингом символ из
альтернатив, для примера, ‘["foo" &or [first case] [second case] ...]’.

   Большинство потребностей удовлетворены этими двумя способами, и откат
   автоматически отключается, но иногда полезно явно отключить возврат
   с помощью 'прохода' спецификации. Это полезно, когда вы знаете, что не
   выше альтернативы не могут применяться. Смотрите пример 'let' спецификации.


File: elisp.info,  Node: Specification Examples,  Prev: Backtracking,  Up: Edebug and Macros

17.2.15.4 Specification Examples
................................

Примеры спецификации
Это может быть легче понять спецификации Edebug, изучая примеры,
представленные здесь.
   A ‘let’ специальная форма имеет последовательность привязок и тела. Каждая
   из привязок является либо символом или подсписок с символом и
   необязательного выражения. В приведенном ниже описании, обратите
   внимание на 'gate' внутри подсписке, чтобы предотвратить возвратов
   раз подсписок найден.

     (def-edebug-spec let
       ((&rest
         &or symbolp (gate symbolp &optional form))
        body))

   Edebug использует следующие спецификации для 'defun' и связанного с
ним списка аргументов и 'interactive' спецификаций. Необходимо
обрабатывать интерактивные формы специально, так как выражение
аргумент фактически оцениваемых вне тела функции. (Спецификация
'defmacro' очень похожа на, что для 'defun', но позволяет 'declar' объявить
заявление.)

     (def-edebug-spec defun
       (&define name lambda-list
                [&optional stringp]   ; Match the doc string, if present.
                [&optional ("interactive" interactive)]
                def-body))

     (def-edebug-spec lambda-list
       (([&rest arg]
         [&optional ["&optional" arg &rest arg]]
         &optional ["&rest" arg]
         )))

     (def-edebug-spec interactive
       (&optional &or stringp def-form))    ; Notice: ‘def-form’

   Спецификация для обратной кавычки ниже показано, как соответствовать
пунктирные списки и используя "nil" прекратить рекурсию. Она также
показывает, как компоненты вектора могут быть сопоставлены. (Фактическая
спецификация определяется Edebug немного отличается, и не поддерживает
пунктирные списки, так как это вызывает очень глубокую рекурсию, что может
потерпеть неудачу.)

     (def-edebug-spec \` (backquote-form))   ; Alias just for clarity.

     (def-edebug-spec backquote-form
       (&or ([&or "," ",@"] &or ("quote" backquote-form) form)
            (backquote-form . [&or nil backquote-form])
            (vector &rest backquote-form)
            sexp))


File: elisp.info,  Node: Edebug Options,  Prev: Edebug and Macros,  Up: Edebug

17.2.16 Edebug Options
----------------------

Эти параметры влияют на поведение Edebug:

 -- User Option: edebug-setup-hook
     Функции для вызова перед использованием Edebug. Каждый раз, когда он
установлен на новое значение, Edebug будет вызывать эти функции один
раз, а затем сбрасывать ‘edebug-setup-hook’ в ‘nil’. Вы можете
использовать эту функцию, чтобы загрузить спецификации Edebug,
связанные с пакетом, который вы используете, но только тогда, когда вы
также используете Edebug.  *Note Instrumenting::.

 -- User Option: edebug-all-defs
     Если не -‘nil’, нормальная оценка определения форм, таких как
     ‘defun’ и ‘defmacro’ инструментирования их для Edebug.  Это относится
     и к ‘eval-defun’, ‘eval-region’, ‘eval-buffer’, и ‘eval-current-buffer’.

     Используй команду ‘M-x edebug-all-defs’ чтобы переключить значение этого
     параметра.  *Note Instrumenting::.

 -- User Option: edebug-all-forms
     Если не-‘nil’, команды ‘eval-defun’, ‘eval-region’, ‘eval-buffer’, и
     ‘eval-current-buffer’ инструментировать все формы, даже те, которые
     ничего не определяют. Это не относится к загрузке или оценок в минибуфере.

     Используй каманду ‘M-x edebug-all-forms’ чтобы изменить значение опции
     *Note Instrumenting::.

 -- User Option: edebug-save-windows
     Если не-‘nil’, Edebug сохраняет и восстанавливает конфигурацию окна. Это
     занимает некоторое время, так что если вас не волнует, что происходит с
     окном конфигурации, лучше установить эту переменную в ‘nil’.

     Если значение является списком, только перечисленные окна будут
     сохранены и восстановлены.

     Вы можете использовать команду 'W' в Edebug чтобы изменить эту переменную
     в интерактивном режиме.  *Note Edebug Display Update::.

 -- User Option: edebug-save-displayed-buffer-points
     Если не-‘nil’, Edebug сохраняет и восстанавливает точку во всех
     отображаемых буферах.

     Сохранение и восстановление точки в других буферов необходимо при
     отладке кода, который изменяет точку буфера, который отображается в
     невыбранные окне. Если Edebug или пользователь затем выбирает окно,
     точка в этом буфере перемещается к значению окна точки.

     Сохранение и восстановление точки во всех буферах является
     дорогостоящим, так как он требует выбора каждого окна в два раза, так
     что включить это только если вам это нужно.  *Note Edebug Display Update::.

 -- User Option: edebug-initial-mode
     Если эта переменная не-‘nil’, это определяет начальный режим выполнения
     для Edebug когда он впервые активирован. Возможные значения ‘step’, ‘next’,
     ‘go’, ‘Go-nonstop’, ‘trace’, ‘Trace-fast’, ‘continue’, и ‘Continue-fast’.

     По умолчанию значение ‘step’.  *Note Edebug Execution Modes::.

 -- User Option: edebug-trace
     Если значение не-‘nil’, отслеживать каждую запись функции и выхода.
     Трассировка вывод отображается в буфере с именем ‘*edebug-trace*’, одна
     запись функции или выход на линию, с отступом от уровня рекурсии.

     Также смотрите ‘edebug-tracing’, в *note Trace Buffer::.

 -- User Option: edebug-test-coverage
     Если не-‘nil’, Edebug проверяет охват всех выражений отлажеваемых.
     *Note Coverage Testing::.

 -- User Option: edebug-continue-kbd-macro
     Если не-‘nil’, продолжить определение или выполнение любой клавиатуры
     макрос, исполняемый за пределами Edebug. Используйте это с осторожностью,
     так как она не отлажена.  *Note Edebug Execution Modes::.

 -- User Option: edebug-unwrap-results
     Если не-‘nil’, Edebug пытается удалить какой-либо из его собственных
     измерительных приборов, при выводе результатов выражений. Это актуально
     при отладке макросов, где результаты выражений сами являются
     инструментированными выражениями. Как очень искусственный пример,
     предположим, что пример функции 'fac' был инструментарован , и рассмотрим
     макрос вида:

          (defmacro test () "Edebug example."
            (if (symbol-function 'fac)
                …))

     Если инструментировать  макрос 'test' и шаг за шагом пройти через него,
     по умолчанию, результат вызова в ‘symbol-function’имеет многочисленные
     ‘edebug-after’ и ‘edebug-before’ формы, которые могут сделать его фактический
     результат трудно читаемый. Если ‘edebug-unwrap-results’ не-'nil',
     Edebug пытается удалить эти формы из результата.

 -- User Option: edebug-on-error
     Edebug связывает ‘debug-on-error’ к этому значению, если ‘debug-on-error’
     ранее ‘nil’.  *Note Trapping Errors::.

 -- User Option: edebug-on-quit
     Edebug связывает ‘debug-on-quit’ к этому значению, если ‘debug-on-quit’ ранее
     ‘nil’.  *Note Trapping Errors::.

   При изменении значений ‘edebug-on-error’ и ‘edebug-on-quit’ в то время как
   Edebug активен, их значения не будут использоваться до следущего запуска Edebug
   с помощью новой команды.

 -- User Option: edebug-global-break-condition
     Если не-‘nil’, для проверки выражений в каждой точке остановки.
     Если результат не-'nil', затем перерыв. Ошибки игнорируются.
     *Note Global Break Condition::.


File: elisp.info,  Node: Syntax Errors,  Next: Test Coverage,  Prev: Edebug,  Up: Debugging

17.3 Debugging Invalid Lisp Syntax
==================================

Отлалка неверного Лисп Синтаксиса
Интерпритатор Лиспа сообщает о неверном синтаксисе, но не может сказать, где
реальная проблема. Например, ошибка “End of file during parsing” в вычислении
выражения указывает на избыток открывающих скобок (или квадратных скобок).
Интерпритатор обнаруживает этот дисбаланс в конце файла, но он не может понять,
где должна быть закрывающая скобка. Кроме того, “Invalid read syntax: ")"”
указывает на избыток закрывающих скобок или отсутствие открывающей скобки, но не
указывает, где недостающая скобка. Как тогда, найти то, что нужно изменить?

   Если проблема не просто дисбаланс скобок, полезный метод, чтобы
попытаться 'C-M-е' в начале каждого определения DEFUN, и посмотреть, если он идет
к месту, где  определение DEFUN появляется до конца. Если этого не произойдет,
есть проблема в этом определении DEFUN.

   Тем не менее, несогласованные круглые скобки являются наиболее
распространенными ошибками синтаксиса Lisp, и мы можем дать дальнейшие
рекомендации для тех случаев. (Кроме того, просто перемещая точку
через код с включенным режимом Show PAREN можно найти несоответствие.)

* Menu:

* Excess Open::     Как найти лишнею или отсутствующую открывающую скобку.
* Excess Close::    Как найти лишнею или отсутствующую закрывающую скобку.


File: elisp.info,  Node: Excess Open,  Next: Excess Close,  Up: Syntax Errors

17.3.1 Excess Open Parentheses
------------------------------

Избыточные открытые скобки.
Первый шаг, найти определение функции, где есть несбалансированные скобки. Если
есть избыточная открытая скобка, нужно перейти в конец файла и ввести 'C-u C-M-u'.
Это переместит вас к началу первого defun определению, который является
несбалансированным.

   Следующим шагом будет точно определить, где ошибка. Нет другого способа,
   чтобы быть уверенным в этом, за исключением, изучить программу, но часто
   существующие отступы является ключом где круглые скобки должны быть. Самый
   простой способ использовать этот ключ ‘C-M-q’и смотреть, что движется.
   *Но не делайте это пока!* Продолжайте читать, в первую очередь.

   Перед тем, как сделать это, убедитесь, что определение DEFUN имеет
   сбалансированые круглые скобки. В противном случае, 'C-M-q' получит ошибку,
   или не будет отступа на всю остальную часть файла до конца. Таким образом,
   перейти к концу определения DEFUN и вставить закрывающую скобку там. Не
   используйте 'C-M-е' переместиться туда, не будет работать до тех пор, пока
   DEFUN не сбалансирован.

   Теперь вы можете перейти к началу определения и введите 'C-M-q'. Как правило,
   все линии от определенной точки до конца функции сместятся вправо. Существует,
   вероятность, нехватки закрывающей скобки или лишняя открывающая скобка, вблизи
   этой точки. (Тем не менее, не думайте, что это верно; Изучайте код, чтобы
   убедиться) После того, как вы нашли несоответствие, отменить 'C-M-q' с 'C-_',
   так как ранние отступы, вероятно, подходят к предполагаемой круглой скобке.

   После того, как вы думаете, что проблема устранена, используйте 'C-M-q' снова.
   Если прежние отступы фактически соответствуют намеченной вложенности скобок,
   и вы положили обратно эти круглые скобки, 'C-M-q' не должны ничего менять.


File: elisp.info,  Node: Excess Close,  Prev: Excess Open,  Up: Syntax Errors

17.3.2 Excess Close Parentheses
-------------------------------

Избыточные закрывающие скобки
Для того, чтобы иметь дело с избытком закрывающей скобкой, сначала
перейдите в начало файла, а затем введите 'C-U -1 C-M-u', чтобы найти
конец первого несбалансированного определения.

   Затем найдите фактическое соответствующую закрывающую скобку, введя 'C-M-f'
   в начале этого определения. Это оставит вас где не хватает места,где
   определение должно закончиться. Вполне возможно, что вы найдете поддельную
   закрывающую скобку в этом районе.

   Если вы не видите проблемы в этой точке, следующее, что нужно сделать, это
   ввести 'C-M-q' в начале определения. Ряд линий, вероятно, сдвинут влево; если
   да, то недостающее открывающая скобка или поддельная закрывающая скобка,
   вероятно, рядом с первой из этих линий. (Тем не менее, не думайте, что это
   верно;. Изучайте код, чтобы убедиться) После того, как вы нашли несоответствие,
   отмените 'C-M-q' с 'C-_', так как преждние отступы, вероятно, подходит к
   предполагаемой круглой скобки.

   После того, как вы думаете, что проблема устранена, используйте 'C-M-q' снова.
   Если преждние отступы фактически соответствуют предполагаемой вложенности
   скобок, и вы положили обратно эти круглые скобки, 'C-M-q' не должно ничего
   менять.


File: elisp.info,  Node: Test Coverage,  Next: Profiling,  Prev: Syntax Errors,  Up: Debugging

17.4 Test Coverage
==================

Тестовое покрытие
Вы можете сделать тестирование покрытия для файла Лиспа кода путем
загрузки 'testcover' библиотеку и используя команду ‘M-x testcover-start <RET>
FILE <RET>’ для инструментирования кода. Затем проверьте код, вызывая его один
или несколько раз. Затем используйте команду ‘M-x testcover-mark-all’, чтобы
отобразить цветные блики на код, чтобы показать, где охват является недостаточным.
Команда ‘M-x testcover-next-mark’ будет двигать вперед точку к следующему
выделенному месту.

   Как правило, красная подсветка указывает на форму которая не полностью оценена;
   коричневый изюминка означает, что она всегда оценивается на ту же величину
   (значений было мало , при тестировании результата). Тем не менее, Красная
   подсветка пропускается для форм, которые не могут завершить свою оценку,
   таких как 'error'. Коричневое изюминкой пропускается для форм, которые, как
   ожидается, всегда имеют одно значение, например, ‘(setq x 14)’.

   Для сложных случаев, вы можете добавить в ваш
   код, чтобы давать советы инструментирования тестового покрытия.

 -- Macro: 1value form
     Вычисляет FORM и возвращает его значение, но сообщает, что тестирование
     покрытия вычисления FORM's всегда должны быть одинаковыми.

 -- Macro: noreturn form
     Оценивает FORM, информирование тестирование покрытия FORM никогда не должны
     возвращаться. Если он когда-нибудь действительно возвращается, вы получите
     сообщение об ошибке во время выполнения программы.

   Edebug также имеет функцию тестирования покрытия (*note Coverage Testing::).
   Эти особенности частично дублируют друг друга, и было бы лучше,
   объединить их.


File: elisp.info,  Node: Profiling,  Prev: Test Coverage,  Up: Debugging

17.5 Profiling
==============

Если ваша программа работает правильно, но вы хотите, чтобы работала быстрее или
эффективнее, первое, что нужно сделать, это "profile" ваш код так, что бы вы
знали, как она использует ресурсы. Если вы обнаружите, что одна конкретная функция
отвечает за значительную часть времени выполнения, вы можете начать искать пути
оптимизации этого куска.

   Emacs имеет встроенную поддержку для этого. Чтобы начать профилирование,
   используйте ‘M-x profiler-start’. Вы можете выбрать профиль с помощью
   использования процессора, использование памяти, или обоих. После выполнения
   некоторых работ, используйте ‘M-x profiler-report’ чтобы отобразить буфер
   резюме для каждого ресурса, который вы выбрали для профилирования. Названия
   буферов отчетов включают в себя время, в которое сгенерированные отчеты, так
   что вы можете создать другой отчет позже без стирания предыдущих результатов.
   Когда вы закончили профилирование, введите ‘M-x profiler-stop’ (есть небольшие
   накладные расходы, связанные с профилированием).

   В докладе профилировщику буфера показывает, на каждой строке, функции,
которая была вызвана, а затем сколько ресурсов (процессор или память)
он используется в абсолютном и процентном раз с начала
профилирование. Если данная линия имеет символ "+" на левой стороне,
вы можете расширить эту строку, набрав <RET>, чтобы увидеть функцию
(и) которые  вызывается функцией верхнего уровня. Нажатие <RET> снова вернет
обратно в исходное состояние.

   Нажмите 'j' или 'mouse-2', чтобы перейти к определению функции. Нажмите
'd' для просмотра документации функции. Вы можете сохранить профиль в
файл с помощью 'C-х С-w'. Вы можете сравнить два профиля, используя '='.

   "elp" библиотека предлагает альтернативный подход. Смотрите файл
'elp.el' для получения инструкций.

   Вы можете проверить скорость отдельных форм Emacs Lisp, используя
‘benchmark’ библиотеку. См функции ‘benchmark-run’ и
‘benchmark-run-compiled’ в ‘benchmark.el’.

   Для профилирования Emacs на уровне его С кода, вы можете создать его с
помощью ‘--enable-profiling’ опции 'configure'. Когда Emacs выходит, он создает
файл 'gmon.out', который вы можете исследовать с помощью утилиты 'gprof'. Эта
функция в основном используется для отладки Emacs. Это фактически останавливает
Lisp-level ‘M-x profiler-…’ команды, описанные выше, для работы.
